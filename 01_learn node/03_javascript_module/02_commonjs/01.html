<!DOCTYPE html>
<html lang="en">
    <head>
        <title></title>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link href="css/style.css" rel="stylesheet">
    </head>
    <body>
    
    </body>
</html>


<!-- 
    CommonJS是一个规范，最初提出来是在浏览器以外的地方使用，并且当时被命名为ServerJS
    后来为了体现它的广泛性，修改为CommonJS，平时我们也会简称为CJS
        
    Node是CommonJS在服务器端一个具有代表性的实现
    Browserify是CommonJS在浏览器中的一种实现
    webpack打包工具具备对CommonJS的支持和转换

    Node中对CommonJS进行了支持和实现，让我们在开发node的过程中可以方便的进行模块化开发；
    在Node中每一个js文件都是一个单独的模块
    这个模块中包括CommonJS规范的核心变量： exports、module.exports、require
    我们可以使用这些变量来方便的进行模块化管理

    实际上，exports中的对象是引用赋值

    在Node中，常常是通过module.exports导出的，module.exports和exports有什么关系呢？
    CommonJS中是没有module.exports的概念的，但是为了实现模块的导出，Node中
    使用的是Module的类，每一个模块都是Module的一个实例，也就是module
    所以在Node中真正用于导出的其实根本就不是exports，而是module.exports;

    CommonJS加载过程是同步的
    一：模块在被第一次引入时，模块中的js代码会被运行一次
    二：模块被多次引入时，会缓存，最终只加载一次（每个模块对象module都有
    一个loaded属性，为false表示还没有加载，为true表示已经加载）


    如果有循环引入，那么加载顺序是什么？
    如果出现循环引用，就是一种数据结构：图结构
    图结构在遍历的过程中，有深度优先搜索和广度优先搜索
    Node采用的为深度优先算法


    CommonJS规范缺点
    CommonJS加载模块是同步的
    同步意味着只有等到对应的模块加载完毕，当前模块中的内容才能被运行
    这个在服务器不会有什么问题，因为服务器加载的js文件都是本地文件，加载速度非常快

    如果将它应用于浏览器呢？
    浏览器加载js文件需要先从服务器上将文件下载下来，之后再加载运行；
    那么采用同步的就意味着后续的js代码都无法正常运行，即使是一些简单的DOM操作；

    所以在浏览器中，我们通常不使用CommonJS规范
    当然在webpack中使用CommonJS是另外一回事
    因为它会将我们的代码转成浏览器可以直接执行的代码

    在早起为了可以在浏览器中使用模块化，通常会采用AMD或CMD
    但是目前一方面现代的浏览器已经支持ES Modules，另一方面借助于webpack等工具可以实现对CommonJS或者ES Module代码的转换
-->