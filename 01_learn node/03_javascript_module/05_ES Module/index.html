<!DOCTYPE html>
<html lang="en">
    <head>
        <title></title>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link href="css/style.css" rel="stylesheet">
    </head>
    <body>
        <script src="./index.js" type="module"></script>
    </body>
</html>
    

<!-- 
  JavaScript 没有模块化一直是它的痛点，所以在ES推出自己的模块化系统时，大家也是异常兴奋

  ESModule和CommonJS的模块化有一些不同之处：
  一方面它使用了import和export关键字
  另一方面它采用编译器的静态分析，也加入了动态引用的方式

  ES Module模块采用export和import关键字来实现模块化
  export负责将模块内的内容导出
  import负责从其他模块导入内容

  采用ES Module将自动采用严格模式： use strict

  export和import可以结合使用
  export { sum as barSum } from './bar.js'
  在开发和封装一个功能库时，通常我们希望将所有暴露的所有接口放到一个文件中；
  这样方便指定统一的接口规范，也方便阅读
  这个时候 我们就可以使用export和import结合使用

  在导出export的时候指定了名字，在导入import的时候需要知道具体的名字（named exports）

  还有一种导出叫默认导出（default export）
  默认导出export时可以不需要指定名字
  在导入时不需要使用{}，并且可以自己来指定名字
  它也方便我们和现有的CommonJS等规范相互操作

  注意：在一个模块中，只能有一个默认导出（default export）


  ES Module加载js文件的过程是编译（解析）时加载的，并且是异步的
  编译时（解析）加载，意味着import不能和运行时相关的内容放在一起使用
  比如from后面的路径需要动态获取
  比如不能将import放到if等语句的代码块中
  所以我们有时候也称ES Module是静态解析的，而不是动态或者运行时解析的

-->

